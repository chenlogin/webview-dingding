## 钉钉小程序
* 小程序包含一个描述整体程序的 app 和多个描述各自页面的 page
    * app 用来描述整体程序，由以下三个文件组成，必须放在项目的根目录
        * app.js，小程序逻辑
        * app.json，小程序公共设置
        * app.acss，小程序公共样式表
    * page 用来描述各个页面，由以下四个文件组成，这四个文件必须具有相同的路径与文件名。开发者写的所有代码最终将会打包成一份 JavaScript 脚本，在小程序启动的时候运行，在小程序结束运行时销毁。
        * js，页面逻辑
        * axml，页面结构
        * acss，页面样式表
        * json，页面配置
* 下载
    * 小程序无需安装，用户第一次使用小程序时，钉钉会从服务器下载小程序的资源，下载后的小程序资源会缓存在钉钉客户端一段时间。当用户再次打开已经缓存资源的小程序时，会跳过下载过程，更快地打开小程序。
* 小程序启动
    * 冷启动，如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。此时小程序会执行初始化，初始化完成后，会触发 onLaunch 回调函数。
    * 热启动，如果用户已经打开过某小程序，在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程称为热启动。此时，onShow 函数会触发，onLaunch 回调函数不会被触发。
* 缓存
    * 开启本地缓存数据，进行存储、获取和删除等控制。 单个小程序的缓存总上限为 10MB。 同步方法会阻塞当前任务，直到同步方法处理返回。异步方法不会阻塞当前任务
* 小程序销毁时机
    * 用户点击右上角关闭按钮关闭小程序时，小程序仅是进入后台运行，不会被销毁。只有当小程序进入后台运行状态一定时间，或者占用系统资源过高时，才会被真正销毁。
* 启动时更新
    * 小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果距离上一次更新版本超过 48 小时，则会等待新版本的代码包被下载后，直接使用新版本启动。
    * 如果需要马上应用最新版本，可以使用dd.UpdateManager()API进行处理。

* App
    * 全局的数据可以在 App() 中设置，各个子页面通过全局函数 getApp() 可以获取全局的应用实例
        * App()必须在 app.js 里调用，且不能调用多次。
        * 不要在 App() 内定义的函数中调用 getApp()，使用 this 就可以拿到 app 实例。
        * 不要在 onLaunch 里调用getCurrentPages，这个时候 page 还没有生成。
        * 通过 getApp() 获取实例之后，不要私自调用生命周期函数。
    * 全局变量如果在一个页面中被改变，会在所有页面中都有效。
    * 框架并非运行在浏览器中，所以 JavaScript 在 web 中的一些能力都无法使用，如 document、window等对象。
    * 由于 node_modules 里第三方模块代码不会经过转换器，为了确保各个终端兼容，node_modules 下的代码需要转成 es5 格式再引用，模块格式推荐使用 es2015 的 import/export。浏览器相关web能力同样无法使用
* Page
    * Page代表应用的一个页面，负责页面展示和交互。每个页面对应一个子目录，一般有多少个页面，就有多少个子目录。它也是一个构造函数，用来生成页面实例。
    * setData函数用于将数据从逻辑层发送到视图层，同时改变对应的this.data的值。
        * 直接修改this.data无效，无法改变页面的状态，还会造成数据不一致。
        * 请尽量避免一次设置过多的数据,不需要在this.data中预先定义
    * $spliceData同样用于将数据从逻辑层发送到视图层，但是相比于setData，在处理长列表的时候，其具有更高的性能。
* AXML
    * import可以加载已经定义好的template,import有作用域的概念，只会import目标文件中定义的template。比如，C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A中定义的template
    * include可以将目标文件除了template标签的整个代码引入，相当于是拷贝到include位置
* 事件
    * key 以on或catch开头，然后跟上事件的类型，onTap（冒泡）, catchTap（非冒泡）
    * dataset在组件中可以定义数据，这些数据将会通过事件传递给逻辑层。以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)，如data-element-type，最终会在event.target.dataset中会将连字符转成驼峰elementType
* 自定义组件
    * 页面配置中说明要使用哪个自定义组件，主要指定组件标签名字和组件所在路径
    * 项目绝对路径以 / 开头，相对路径以 ./ 或者 ../ 开头，npm 路径不以 / 开头
* 小程序scheme规则适用于以下场景：
    * 从 H5 跳转到某个小程序。
    * 生成一个二维码，供用户通过钉钉扫码打开小程序。从 H5 跳转到小程序，可以使用dd.biz.util.openLink
* web-view
    * 一个可以用来承载H5网页的组件，自动铺满整个小程序页面，并覆盖其它组件。需要开发者到开发者后台配置渲染H5网页的安全域名。

## H5微应用
* npm install dingtalk-jsapi --save
* 不推荐使用浏览器引入方法，这样无法按需加载，而且难以获得底层依赖模块的 bug 快速修复支持，https://g.alicdn.com/dingding/dingtalk-jsapi/2.10.3/dingtalk.open.js
* 钉钉提供的JSAPI有很多是手机的基础能力，对这些JSAPI的调用不需要进行鉴权（即不需要进行dd.config），只需要保证在dd.ready里面调用即可。对于一些钉钉业务相关、安全相关的JSAPI的调用，需要开发者先进行鉴权然后再调用
